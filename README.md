# 刷题题解

## 数组、栈、队列

### [LeetCode_232_用栈实现队列](/src/题解/数组_栈_队列/LeetCode_232_用栈实现队列.md)

> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）


### [LeetCode_394_字符串解码](/src/题解/数组_栈_队列/LeetCode_394_字符串解码.md)

> 给定一个经过编码的字符串，返回它解码后的字符串。
>
> 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。


### [LeetCode_768_最多能完成排序的块II](/src/题解/数组_栈_队列/LeetCode_768_最多能完成排序的块II.md)

> arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
>
> 我们最多能将数组分成多少块？
> 

### [LeetCode_821_字符的最短距离](/src/题解/数组_栈_队列/LeetCode_821_字符串的最短距离.md)

> 给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。
>
> 返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。
>
> 两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。


### [LeetCode_989_数组形式的整数加法](/src/题解/数组_栈_队列/LeetCode_989_数组形式的整数加法.md)

> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。
>
> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。


### [LeetCode_1381_设计一个支持增量操作的栈](/src/题解/数组_栈_队列/LeetCode_1381_设计一个支持增量操作的栈.md)

> 实现自定义栈类 CustomStack ：
> 
> void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。



## 链表

### [LeetCode_61_旋转链表](/src/题解/链表/LeetCode_61_旋转链表.md)

> 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。



## 树

### [LeetCode_109_有序链表转换二叉搜索树](/src/题解/树/LeetCode_109_有序链表转换二叉搜索树.md)

> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。











### Doing...
























