# 刷题题解

## 数组、栈、队列

### [LeetCode_232_用栈实现队列](/src/题解/数组_栈_队列/LeetCode_232_用栈实现队列.md)

> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）


### [LeetCode_394_字符串解码](/src/题解/数组_栈_队列/LeetCode_394_字符串解码.md)

> 给定一个经过编码的字符串，返回它解码后的字符串。
>
> 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。


### [LeetCode_768_最多能完成排序的块II](/src/题解/数组_栈_队列/LeetCode_768_最多能完成排序的块II.md)

> arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
>
> 我们最多能将数组分成多少块？
> 

### [LeetCode_821_字符的最短距离](/src/题解/数组_栈_队列/LeetCode_821_字符串的最短距离.md)

> 给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。
>
> 返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。
>
> 两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。


### [LeetCode_989_数组形式的整数加法](/src/题解/数组_栈_队列/LeetCode_989_数组形式的整数加法.md)

> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。
>
> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。


### [LeetCode_1381_设计一个支持增量操作的栈](/src/题解/数组_栈_队列/LeetCode_1381_设计一个支持增量操作的栈.md)

> 实现自定义栈类 CustomStack ：
> 
> void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。



## 链表

### [LeetCode_61_旋转链表](/src/题解/链表/LeetCode_61_旋转链表.md)

> 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。


### [LeetCode_24_两两交换链表中的节点](/src/题解/链表/LeetCode_24_两两交换链表中的节点.md)

> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
> 
> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

### [LeetCode_109_有序链表转换二叉搜索树](/src/题解/链表/LeetCode_109_有序链表转换二叉搜索树.md)

> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。


### [LeetCode_160_相交链表](/src/题解/链表/LeetCode_160_相交链表.md)

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。


### [LeetCode_142_环形链表II](/src/题解/链表/LeetCode_142_环形链表II.md)

带双指针图解

> 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
> 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
>
> 说明：不允许修改给定的链表。


### [LeetCode_146_LRU缓存机制](/src/题解/链表/LeetCode_146_LRU缓存机制.md)

> 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。



## 树


### [LeetCode_104_二叉树的最大深度](/src/题解/树/LeetCode_104_二叉树的最大深度.md)

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。


### [LeetCode_100_相同的树](/src/题解/树/LeetCode_100_相同的树.md)

> 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。


### [Doing](/src/题解/树/Doing.md)

> 































